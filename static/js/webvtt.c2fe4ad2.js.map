{"version":3,"sources":["webpack:///./node_modules/_fluid-player@3.0.4@fluid-player/vendor/webvtt.js"],"names":["WebVTTParser","this","parse","input","mode","NEWLINE","startTime","Date","now","linePos","lines","split","alreadyCollected","cues","errors","err","message","col","push","line","lineLength","length","signature","bom","signature_length","indexOf","undefined","cue","id","endTime","pauseOnExit","direction","snapToLines","linePosition","textPosition","size","alignment","text","tree","parseTimings","test","timings","WebVTTCueTimingsAndSettingsParser","previousCueStart","cuetextparser","WebVTTCueTextParser","sort","a","b","time","errorHandler","SPACE","NOSPACE","pos","skip","pattern","collect","str","timestamp","val1","val2","val3","val4","units","parseInt","parseSettings","settings","seen","i","index","setting","slice","value","alignValues","join","substring","parseTimestamp","ts","nextToken","state","result","buffer","classes","c","filter","item","cueStart","cueEnd","children","current","timestamps","attach","token","type","name","parent","inScope","node"],"mappings":"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","file":"static/js/webvtt.c2fe4ad2.js","sourcesContent":["// Any copyright is dedicated to the Public Domain.\n// http://creativecommons.org/publicdomain/zero/1.0/\n\n// Not intended to be fast, but if you can make it faster, please help out!\n\nvar WebVTTParser = function() {\n  this.parse = function(input, mode) {\n    //XXX need global search and replace for \\0\n    var NEWLINE = /\\r\\n|\\r|\\n/,\n        startTime = Date.now(),\n        linePos = 0,\n        lines = input.split(NEWLINE),\n        alreadyCollected = false,\n        cues = [],\n        errors = []\n    function err(message, col) {\n      errors.push({message:message, line:linePos+1, col:col})\n    }\n\n    var line = lines[linePos],\n        lineLength = line.length,\n        signature = \"WEBVTT\",\n        bom = 0,\n        signature_length = signature.length\n\n    /* Byte order mark */\n    if (line[0] === \"\\ufeff\") {\n      bom = 1\n      signature_length += 1\n    }\n    /* SIGNATURE */\n    if (\n      lineLength < signature_length ||\n      line.indexOf(signature) !== 0+bom ||\n      lineLength > signature_length &&\n      line[signature_length] !== \" \" &&\n      line[signature_length] !== \"\\t\"\n    ) {\n      err(\"No valid signature. (File needs to start with \\\"WEBVTT\\\".)\")\n    }\n\n    linePos++\n\n    /* HEADER */\n    while(lines[linePos] != \"\" && lines[linePos] != undefined) {\n      err(\"No blank line after the signature.\")\n      if(lines[linePos].indexOf(\"-->\") != -1) {\n        alreadyCollected = true\n        break\n      }\n      linePos++\n    }\n\n    /* CUE LOOP */\n    while(lines[linePos] != undefined) {\n      var cue\n      while(!alreadyCollected && lines[linePos] == \"\") {\n        linePos++\n      }\n      if(!alreadyCollected && lines[linePos] == undefined)\n        break\n\n      /* CUE CREATION */\n      cue = {\n        id:\"\",\n        startTime:0,\n        endTime:0,\n        pauseOnExit:false,\n        direction:\"horizontal\",\n        snapToLines:true,\n        linePosition:\"auto\",\n        textPosition:50,\n        size:100,\n        alignment:\"middle\",\n        text:\"\",\n        tree:null\n      }\n\n      var parseTimings = true\n\n      if(lines[linePos].indexOf(\"-->\") == -1) {\n        cue.id = lines[linePos]\n\n        /* COMMENTS\n           Not part of the specification's parser as these would just be ignored. However,\n           we want them to be conforming and not get \"Cue identifier cannot be standalone\".\n         */\n        if(/^NOTE($|[ \\t])/.test(cue.id)) { // .startsWith fails in Chrome\n          linePos++\n          while(lines[linePos] != \"\" && lines[linePos] != undefined) {\n            if(lines[linePos].indexOf(\"-->\") != -1)\n              err(\"Cannot have timestamp in a comment.\")\n            linePos++\n          }\n          continue\n        }\n\n        linePos++\n\n        if(lines[linePos] == \"\" || lines[linePos] == undefined) {\n          err(\"Cue identifier cannot be standalone.\")\n          continue\n        }\n\n        if(lines[linePos].indexOf(\"-->\") == -1) {\n          parseTimings = false\n          err(\"Cue identifier needs to be followed by timestamp.\")\n        }\n      }\n\n      /* TIMINGS */\n      alreadyCollected = false\n      var timings = new WebVTTCueTimingsAndSettingsParser(lines[linePos], err)\n      var previousCueStart = 0\n      if(cues.length > 0) {\n        previousCueStart = cues[cues.length-1].startTime\n      }\n      if(parseTimings && !timings.parse(cue, previousCueStart)) {\n        /* BAD CUE */\n\n        cue = null\n        linePos++\n\n        /* BAD CUE LOOP */\n        while(lines[linePos] != \"\" && lines[linePos] != undefined) {\n          if(lines[linePos].indexOf(\"-->\") != -1) {\n            alreadyCollected = true\n            break\n          }\n          linePos++\n        }\n        continue\n      }\n      linePos++\n\n      /* CUE TEXT LOOP */\n      while(lines[linePos] != \"\" && lines[linePos] != undefined) {\n        if(lines[linePos].indexOf(\"-->\") != -1) {\n          err(\"Blank line missing before cue.\")\n          alreadyCollected = true\n          break\n        }\n        if(cue.text != \"\")\n          cue.text += \"\\n\"\n        cue.text += lines[linePos]\n        linePos++\n      }\n\n      /* CUE TEXT PROCESSING */\n      var cuetextparser = new WebVTTCueTextParser(cue.text, err, mode)\n      cue.tree = cuetextparser.parse(cue.startTime, cue.endTime)\n      cues.push(cue)\n    }\n    cues.sort(function(a, b) {\n      if (a.startTime < b.startTime)\n        return -1\n      if (a.startTime > b.startTime)\n        return 1\n      if (a.endTime > b.endTime)\n        return -1\n      if (a.endTime < b.endTime)\n        return 1\n      return 0\n    })\n    /* END */\n    return {cues:cues, errors:errors, time:Date.now()-startTime}\n  }\n}\n\nvar WebVTTCueTimingsAndSettingsParser = function(line, errorHandler) {\n  var SPACE = /[\\u0020\\t\\f]/,\n      NOSPACE = /[^\\u0020\\t\\f]/,\n      line = line,\n      pos = 0,\n      err = function(message) {\n        errorHandler(message, pos+1)\n      },\n      spaceBeforeSetting = true\n  function skip(pattern) {\n    while(\n      line[pos] != undefined &&\n      pattern.test(line[pos])\n    ) {\n      pos++\n    }\n  }\n  function collect(pattern) {\n    var str = \"\"\n    while(\n      line[pos] != undefined &&\n      pattern.test(line[pos])\n    ) {\n      str += line[pos]\n      pos++\n    }\n    return str\n  }\n  /* http://dev.w3.org/html5/webvtt/#collect-a-webvtt-timestamp */\n  function timestamp() {\n    var units = \"minutes\",\n        val1,\n        val2,\n        val3,\n        val4\n    // 3\n    if(line[pos] == undefined) {\n      err(\"No timestamp found.\")\n      return\n    }\n    // 4\n    if(!/\\d/.test(line[pos])) {\n      err(\"Timestamp must start with a character in the range 0-9.\")\n      return\n    }\n    // 5-7\n    val1 = collect(/\\d/)\n    if(val1.length > 2 || parseInt(val1, 10) > 59) {\n      units = \"hours\"\n    }\n    // 8\n    if(line[pos] != \":\") {\n      err(\"No time unit separator found.\")\n      return\n    }\n    pos++\n    // 9-11\n    val2 = collect(/\\d/)\n    if(val2.length != 2) {\n      err(\"Must be exactly two digits.\")\n      return\n    }\n    // 12\n    if(units == \"hours\" || line[pos] == \":\") {\n      if(line[pos] != \":\") {\n        err(\"No seconds found or minutes is greater than 59.\")\n        return\n      }\n      pos++\n      val3 = collect(/\\d/)\n      if(val3.length != 2) {\n        err(\"Must be exactly two digits.\")\n        return\n      }\n    } else {\n      val3 = val2\n      val2 = val1\n      val1 = \"0\"\n    }\n    // 13\n    if(line[pos] != \".\") {\n      err(\"No decimal separator (\\\".\\\") found.\")\n      return\n    }\n    pos++\n    // 14-16\n    val4 = collect(/\\d/)\n    if(val4.length != 3) {\n      err(\"Milliseconds must be given in three digits.\")\n      return\n    }\n    // 17\n    if(parseInt(val2, 10) > 59) {\n      err(\"You cannot have more than 59 minutes.\")\n      return\n    }\n    if(parseInt(val3, 10) > 59) {\n      err(\"You cannot have more than 59 seconds.\")\n      return\n    }\n    return parseInt(val1, 10) * 60 * 60 + parseInt(val2, 10) * 60 + parseInt(val3, 10) + parseInt(val4, 10) / 1000\n  }\n\n  /* http://dev.w3.org/html5/webvtt/#parse-the-webvtt-settings */\n  function parseSettings(input, cue) {\n    var settings = input.split(SPACE),\n        seen = []\n    for(var i=0; i < settings.length; i++) {\n      if(settings[i] == \"\")\n        continue\n\n      var index = settings[i].indexOf(':'),\n          setting = settings[i].slice(0, index)\n          value = settings[i].slice(index + 1)\n\n      if(seen.indexOf(setting) != -1) {\n        err(\"Duplicate setting.\")\n      }\n      seen.push(setting)\n\n      if(value == \"\") {\n        err(\"No value for setting defined.\")\n        return\n      }\n\n      if(setting == \"vertical\") { // writing direction\n        if(value != \"rl\" && value != \"lr\") {\n          err(\"Writing direction can only be set to 'rl' or 'rl'.\")\n          continue\n        }\n        cue.direction = value\n      } else if(setting == \"line\") { // line position\n        if(!/\\d/.test(value)) {\n          err(\"Line position takes a number or percentage.\")\n          continue\n        }\n        if(value.indexOf(\"-\", 1) != -1) {\n          err(\"Line position can only have '-' at the start.\")\n          continue\n        }\n        if(value.indexOf(\"%\") != -1 && value.indexOf(\"%\") != value.length-1) {\n          err(\"Line position can only have '%' at the end.\")\n          continue\n        }\n        if(value[0] == \"-\" && value[value.length-1] == \"%\") {\n          err(\"Line position cannot be a negative percentage.\")\n          continue\n        }\n        if(value[value.length-1] == \"%\") {\n          if(parseInt(value, 10) > 100) {\n            err(\"Line position cannot be >100%.\")\n            continue\n          }\n          cue.snapToLines = false\n        }\n        cue.linePosition = parseInt(value, 10)\n      } else if(setting == \"position\") { // text position\n        if(value[value.length-1] != \"%\") {\n          err(\"Text position must be a percentage.\")\n          continue\n        }\n        if(parseInt(value, 10) > 100) {\n          err(\"Size cannot be >100%.\")\n          continue\n        }\n        cue.textPosition = parseInt(value, 10)\n      } else if(setting == \"size\") { // size\n        if(value[value.length-1] != \"%\") {\n          err(\"Size must be a percentage.\")\n          continue\n        }\n        if(parseInt(value, 10) > 100) {\n          err(\"Size cannot be >100%.\")\n          continue\n        }\n        cue.size = parseInt(value, 10)\n      } else if(setting == \"align\") { // alignment\n        var alignValues = [\"start\", \"middle\", \"end\", \"left\", \"right\"]\n        if(alignValues.indexOf(value) == -1) {\n          err(\"Alignment can only be set to one of \" + alignValues.join(\", \") + \".\")\n          continue\n        }\n        cue.alignment = value\n      } else {\n        err(\"Invalid setting.\")\n      }\n    }\n  }\n\n  this.parse = function(cue, previousCueStart) {\n    skip(SPACE)\n    cue.startTime = timestamp()\n    if(cue.startTime == undefined) {\n      return\n    }\n    if(cue.startTime < previousCueStart) {\n      err(\"Start timestamp is not greater than or equal to start timestamp of previous cue.\")\n    }\n    if(NOSPACE.test(line[pos])) {\n      err(\"Timestamp not separated from '-->' by whitespace.\")\n    }\n    skip(SPACE)\n    // 6-8\n    if(line[pos] != \"-\") {\n      err(\"No valid timestamp separator found.\")\n      return\n    }\n    pos++\n    if(line[pos] != \"-\") {\n      err(\"No valid timestamp separator found.\")\n      return\n    }\n    pos++\n    if(line[pos] != \">\") {\n      err(\"No valid timestamp separator found.\")\n      return\n    }\n    pos++\n    if(NOSPACE.test(line[pos])) {\n      err(\"'-->' not separated from timestamp by whitespace.\")\n    }\n    skip(SPACE)\n    cue.endTime = timestamp()\n    if(cue.endTime == undefined) {\n      return\n    }\n    if(cue.endTime <= cue.startTime) {\n      err(\"End timestamp is not greater than start timestamp.\")\n    }\n\n    if(NOSPACE.test(line[pos])) {\n      spaceBeforeSetting = false\n    }\n    skip(SPACE)\n    parseSettings(line.substring(pos), cue)\n    return true\n  }\n  this.parseTimestamp = function() {\n    var ts = timestamp()\n    if(line[pos] != undefined) {\n      err(\"Timestamp must not have trailing characters.\")\n      return\n    }\n    return ts\n  }\n}\n\nvar WebVTTCueTextParser = function(line, errorHandler, mode) {\n  var line = line,\n      pos = 0,\n      err = function(message) {\n        if(mode == \"metadata\")\n          return\n        errorHandler(message, pos+1)\n      }\n\n  this.parse = function(cueStart, cueEnd) {\n    var result = {children:[]},\n        current = result,\n        timestamps = []\n\n    function attach(token) {\n      current.children.push({type:\"object\", name:token[1], classes:token[2], children:[], parent:current})\n      current = current.children[current.children.length-1]\n    }\n    function inScope(name) {\n      var node = current\n      while(node) {\n        if(node.name == name)\n          return true\n        node = node.parent\n      }\n      return\n    }\n\n    while(line[pos] != undefined) {\n      var token = nextToken()\n      if(token[0] == \"text\") {\n        current.children.push({type:\"text\", value:token[1], parent:current})\n      } else if(token[0] == \"start tag\") {\n        if(mode == \"chapters\")\n          err(\"Start tags not allowed in chapter title text.\")\n        var name = token[1]\n        if(name != \"v\" && name != \"lang\" && token[3] != \"\") {\n          err(\"Only <v> and <lang> can have an annotation.\")\n        }\n        if(\n          name == \"c\" ||\n          name == \"i\" ||\n          name == \"b\" ||\n          name == \"u\" ||\n          name == \"ruby\"\n        ) {\n          attach(token)\n        } else if(name == \"rt\" && current.name == \"ruby\") {\n          attach(token)\n        } else if(name == \"v\") {\n          if(inScope(\"v\")) {\n            err(\"<v> cannot be nested inside itself.\")\n          }\n          attach(token)\n          current.value = token[3] // annotation\n          if(!token[3]) {\n            err(\"<v> requires an annotation.\")\n          }\n        } else if(name == \"lang\") {\n          attach(token)\n          current.value = token[3] // language\n        } else {\n          err(\"Incorrect start tag.\")\n        }\n      } else if(token[0] == \"end tag\") {\n        if(mode == \"chapters\")\n          err(\"End tags not allowed in chapter title text.\")\n        // XXX check <ruby> content\n        if(token[1] == current.name) {\n          current = current.parent\n        } else if(token[1] == \"ruby\" && current.name == \"rt\") {\n          current = current.parent.parent\n        } else {\n          err(\"Incorrect end tag.\")\n        }\n      } else if(token[0] == \"timestamp\") {\n        if(mode == \"chapters\")\n          err(\"Timestamp not allowed in chapter title text.\")\n        var timings = new WebVTTCueTimingsAndSettingsParser(token[1], err),\n            timestamp = timings.parseTimestamp()\n        if(timestamp != undefined) {\n          if(timestamp <= cueStart || timestamp >= cueEnd) {\n            err(\"Timestamp must be between start timestamp and end timestamp.\")\n          }\n          if(timestamps.length > 0 && timestamps[timestamps.length-1] >= timestamp) {\n            err(\"Timestamp must be greater than any previous timestamp.\")\n          }\n          current.children.push({type:\"timestamp\", value:timestamp, parent:current})\n          timestamps.push(timestamp)\n        }\n      }\n    }\n    while(current.parent) {\n      if(current.name != \"v\") {\n        err(\"Required end tag missing.\")\n      }\n      current = current.parent\n    }\n    return result\n  }\n\n  function nextToken() {\n    var state = \"data\",\n        result = \"\",\n        buffer = \"\",\n        classes = []\n    while(line[pos-1] != undefined || pos == 0) {\n      var c = line[pos]\n      if(state == \"data\") {\n        if(c == \"&\") {\n          buffer = c\n          state = \"escape\"\n        } else if(c == \"<\" && result == \"\") {\n          state = \"tag\"\n        } else if(c == \"<\" || c == undefined) {\n          return [\"text\", result]\n        } else {\n          result += c\n        }\n      } else if(state == \"escape\") {\n        if(c == \"&\") {\n          err(\"Incorrect escape.\")\n          result += buffer\n          buffer = c\n        } else if(/[abglmnsprt]/.test(c)) {\n          buffer += c\n        } else if(c == \";\") {\n          if(buffer == \"&amp\") {\n            result += \"&\"\n          } else if(buffer == \"&lt\") {\n            result += \"<\"\n          } else if(buffer == \"&gt\") {\n            result += \">\"\n          } else if(buffer == \"&lrm\") {\n            result += \"\\u200e\"\n          } else if(buffer == \"&rlm\") {\n            result += \"\\u200f\"\n          } else if(buffer == \"&nbsp\") {\n            result += \"\\u00A0\"\n          } else {\n            err(\"Incorrect escape.\")\n            result += buffer + \";\"\n          }\n          state = \"data\"\n        } else if(c == \"<\" || c == undefined) {\n          err(\"Incorrect escape.\")\n          result += buffer\n          return [\"text\", result]\n        } else {\n          err(\"Incorrect escape.\")\n          result += buffer + c\n          state = \"data\"\n        }\n      } else if(state == \"tag\") {\n        if(c == \"\\t\" || c == \"\\n\" || c == \"\\f\" || c == \" \") {\n          state = \"start tag annotation\"\n        } else if(c == \".\") {\n          state = \"start tag class\"\n        } else if(c == \"/\") {\n          state = \"end tag\"\n        } else if(/\\d/.test(c)) {\n          result = c\n          state = \"timestamp tag\"\n        } else if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          return [\"start tag\", \"\", [], \"\"]\n        } else {\n          result = c\n          state = \"start tag\"\n        }\n      } else if(state == \"start tag\") {\n        if(c == \"\\t\" || c == \"\\f\" || c == \" \") {\n          state = \"start tag annotation\"\n        } else if(c == \"\\n\") {\n          buffer = c\n          state = \"start tag annotation\"\n        } else if(c == \".\") {\n          state = \"start tag class\"\n        } else if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          return [\"start tag\", result, [], \"\"]\n        } else {\n          result += c\n        }\n      } else if(state == \"start tag class\") {\n        if(c == \"\\t\" || c == \"\\f\" || c == \" \") {\n          classes.push(buffer)\n          buffer = \"\"\n          state = \"start tag annotation\"\n        } else if(c == \"\\n\") {\n          classes.push(buffer)\n          buffer = c\n          state = \"start tag annotation\"\n        } else if(c == \".\") {\n          classes.push(buffer)\n          buffer = \"\"\n        } else if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          classes.push(buffer)\n          return [\"start tag\", result, classes, \"\"]\n        } else {\n          buffer += c\n        }\n      } else if(state == \"start tag annotation\") {\n        if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          buffer = buffer.split(/[\\u0020\\t\\f\\r\\n]+/).filter(function(item) { if(item) return true }).join(\" \")\n          return [\"start tag\", result, classes, buffer]\n        } else {\n          buffer +=c\n        }\n      } else if(state == \"end tag\") {\n        if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          return [\"end tag\", result]\n        } else {\n          result += c\n        }\n      } else if(state == \"timestamp tag\") {\n        if(c == \">\" || c == undefined) {\n          if(c == \">\") {\n            pos++\n          }\n          return [\"timestamp\", result]\n        } else {\n          result += c\n        }\n      } else {\n        err(\"Never happens.\") // The joke is it might.\n      }\n      // 8\n      pos++\n    }\n  }\n}\n\nvar WebVTTSerializer = function() {\n  function serializeTree(tree) {\n    var result = \"\"\n    for (var i = 0; i < tree.length; i++) {\n      var node = tree[i]\n      if(node.type == \"text\") {\n        result += node.value\n      } else if(node.type == \"object\") {\n        result += \"<\" + node.name\n        if(node.classes) {\n          for(var y = 0; y < node.classes.length; y++) {\n            result += \".\" + node.classes[y]\n          }\n        }\n        if(node.value) {\n          result += \" \" + node.value\n        }\n        result += \">\"\n        if(node.children)\n          result += serializeTree(node.children)\n        result += \"</\" + node.name + \">\"\n      } else {\n        result += \"<\" + node.value + \">\"\n      }\n    }\n    return result\n  }\n  function serializeCue(cue) {\n    return cue.startTime + \" \" + cue.endTime + \"\\n\" + serializeTree(cue.tree.children) + \"\\n\\n\"\n  }\n  this.serialize = function(cues) {\n    var result = \"\"\n    for(var i=0;i<cues.length;i++) {\n      result += serializeCue(cues[i])\n    }\n    return result\n  }\n}\n\nexport default WebVTTParser;\n"],"sourceRoot":""}